// lib/composite_test.ts
import { assertEquals } from "jsr:@std/assert@^1.0.0/equals";
import { join, normalize } from "jsr:@std/path@^1.0.0";
import {
  compose,
  type ComposeContext,
  type CompositeDialect,
  defaultEmitter,
  type DiscoveredDb,
  type GlobWalker,
  type SqlEmitter,
} from "./composite.ts";

// deno-lint-ignore no-explicit-any
type Any = any;

/**
 * Deterministic test emitter:
 * - stable header/footer (no timestamps)
 * - uses defaultEmitter.attach so we validate dialect-aware ATTACH syntax and path handling
 *
 * Notes:
 * - compose() always returns SQL ending with exactly one trailing "\n".
 * - For multi-line DDL (views), set extraSqlOrder="asProvided" so line order is preserved.
 */
const testEmitter: SqlEmitter = {
  header(ctx: ComposeContext<unknown>) {
    const lines: string[] = [];
    lines.push("-- TEST: Auto-generated by compose()");
    lines.push(
      `-- TEST: dialect=${ctx.dialect} scope=${ctx.scope}${
        ctx.tenantId ? ` tenantId=${ctx.tenantId}` : ""
      }`,
    );
    lines.push("");

    for (const pragma of ctx.pragmas) lines.push(pragma);
    if (ctx.pragmas.length) lines.push("");

    return lines;
  },
  attach(db: DiscoveredDb<unknown>, ctx: ComposeContext<unknown>) {
    // Validate dialect-aware attach formatting by delegating to the real emitter.
    return defaultEmitter.attach!(
      db as unknown as DiscoveredDb<Any>,
      ctx as unknown as ComposeContext<Any>,
    );
  },
  footer(ctx: ComposeContext<unknown>) {
    const lines: string[] = [];
    if (ctx.extraSql.length) {
      lines.push("");
      lines.push("-- extra SQL (views, etc.)");
      lines.push(...ctx.extraSql);
    }
    // Do not append a final "" here; the core compose() adds the final "\n".
    return lines;
  },
};

function makeMockWalker(paths: readonly string[]): GlobWalker {
  return {
    async *walk(
      _globs: readonly string[],
      _opts?: { readonly cwd?: string; readonly ignore?: readonly string[] },
    ) {
      for (const p of paths) yield p;
    },
  };
}

async function runCompose(args: {
  volumeRoot: string;
  scope: "admin" | "cross-tenant" | "tenant";
  tenantId?: string;
  dialect: CompositeDialect;
  discoveredAbsPaths: readonly string[];
  configureExtras?: (ctx: ComposeContext<unknown>) => Record<string, unknown>;
}) {
  return await compose({
    layout: { volumeRoot: args.volumeRoot },
    scope: args.scope,
    tenantId: args.tenantId,
    dialect: args.dialect,
    walker: makeMockWalker(args.discoveredAbsPaths),
    configure: (ctx) => ({
      globs: ["**/*.sqlite.db", "**/*.db", "**/*.sqlite"],
      emitter: testEmitter,

      // Make aliasing explicitly stable: pure function of stableKey (relative path)
      aliasForKey: (stableKey: string) => {
        const file = stableKey.split("/").pop() ?? stableKey;
        return file.replace(/\.sqlite(\.db)?$/i, "").replace(/\.db$/i, "");
      },

      ...(args.configureExtras?.(ctx) ?? {}),
    }),
  });
}

Deno.test("compose() emits deterministic composite.sql (SQLite + DuckDB dialects) via golden strings", async (t) => {
  const volumeRoot = "/vol";

  await t.step(
    "SQLite admin: dedupe + sort + SQLite ATTACH syntax",
    async () => {
      const baseDir = join(volumeRoot, "embedded", "admin");

      const discovered = [
        normalize(join(baseDir, "db9.sqlite.db")),
        normalize(join(baseDir, "db0.sqlite.db")),
        normalize(join(baseDir, "db0.sqlite.db")), // dup
        normalize(join(baseDir, "db2.sqlite.db")),
      ];

      const result = await runCompose({
        volumeRoot,
        scope: "admin",
        dialect: "SQLite",
        discoveredAbsPaths: discovered,
      });

      const golden = [
        "-- TEST: Auto-generated by compose()",
        "-- TEST: dialect=SQLite scope=admin",
        "",
        "ATTACH DATABASE 'db0.sqlite.db' AS db0;",
        "ATTACH DATABASE 'db2.sqlite.db' AS db2;",
        "ATTACH DATABASE 'db9.sqlite.db' AS db9;",
        "",
      ].join("\n");

      assertEquals(result.sql, golden);
    },
  );

  await t.step(
    "DuckDB admin: dedupe + sort + DuckDB ATTACH syntax",
    async () => {
      const baseDir = join(volumeRoot, "embedded", "admin");

      const discovered = [
        normalize(join(baseDir, "db2.sqlite.db")),
        normalize(join(baseDir, "db0.sqlite.db")),
        normalize(join(baseDir, "db9.sqlite.db")),
      ];

      const result = await runCompose({
        volumeRoot,
        scope: "admin",
        dialect: "DuckDB",
        discoveredAbsPaths: discovered,
        configureExtras: (_ctx) => ({
          // For DuckDB attaching SQLite files, callers typically need this preamble.
          // Keep order asProvided since INSTALL then LOAD order matters.
          pragmaOrder: "asProvided",
          pragmas: () => ["INSTALL sqlite;", "LOAD sqlite;"],
        }),
      });

      const golden = [
        "-- TEST: Auto-generated by compose()",
        "-- TEST: dialect=DuckDB scope=admin",
        "",
        "INSTALL sqlite;",
        "LOAD sqlite;",
        "",
        "ATTACH 'db0.sqlite.db' AS db0 (TYPE sqlite);",
        "ATTACH 'db2.sqlite.db' AS db2 (TYPE sqlite);",
        "ATTACH 'db9.sqlite.db' AS db9 (TYPE sqlite);",
        "",
      ].join("\n");

      assertEquals(result.sql, golden);
    },
  );

  await t.step(
    "cross-tenant SQLite: ignores composite files yielded by walker",
    async () => {
      const baseDir = join(volumeRoot, "embedded", "cross-tenant");

      const discovered = [
        normalize(join(baseDir, "db1.sqlite.db")),
        normalize(join(baseDir, "db2.sqlite.db")),
        // Even if yielded, core ignores these by default
        normalize(join(baseDir, "composite.sql")),
        normalize(join(baseDir, "composite.sqlite.auto.db")),
      ];

      const result = await runCompose({
        volumeRoot,
        scope: "cross-tenant",
        dialect: "SQLite",
        discoveredAbsPaths: discovered,
        configureExtras: () => ({
          // Demonstrate stable deterministic aliasing that does not depend on discovery order
          aliasForKey: (stableKey: string) => {
            const file = stableKey.split("/").pop() ?? stableKey;
            const stem = file.replace(/\.sqlite(\.db)?$/i, "").replace(
              /\.db$/i,
              "",
            );
            return `cross_${stem}`;
          },
        }),
      });

      const golden = [
        "-- TEST: Auto-generated by compose()",
        "-- TEST: dialect=SQLite scope=cross-tenant",
        "",
        "ATTACH DATABASE 'db1.sqlite.db' AS cross_db1;",
        "ATTACH DATABASE 'db2.sqlite.db' AS cross_db2;",
        "",
      ].join("\n");

      assertEquals(result.sql, golden);
    },
  );

  await t.step(
    "tenant SQLite: pragmas sorted + extraSql preserved asProvided for multi-line view",
    async () => {
      const tenantId = "tenant-123";
      const baseDir = join(volumeRoot, "embedded", "tenant", tenantId);

      const discovered = [
        // out of order on purpose
        normalize(join(baseDir, "db4.sqlite.db")),
        normalize(join(baseDir, "db3.sqlite.db")),
      ];

      const result = await runCompose({
        volumeRoot,
        scope: "tenant",
        tenantId,
        dialect: "SQLite",
        discoveredAbsPaths: discovered,
        configureExtras: () => ({
          // Pragmas: default is "sorted"; provide unsorted with duplicates to verify sort+dedupe.
          pragmas: () => [
            "PRAGMA synchronous = NORMAL;",
            "PRAGMA journal_mode = WAL;",
            "PRAGMA journal_mode = WAL;",
          ],
          // For view DDL, preserve author order (do NOT sort line-by-line).
          extraSqlOrder: "asProvided",
          extraSql: (dbs: readonly DiscoveredDb<unknown>[]) => {
            const unions = dbs.map((d) =>
              `SELECT '${d.alias}' AS source_db, * FROM ${d.alias}.evidence`
            );
            return [
              `CREATE VIEW IF NOT EXISTS all_evidence AS\n${
                unions.join("\nUNION ALL\n")
              };`,
            ];
          },
        }),
      });

      const golden = [
        "-- TEST: Auto-generated by compose()",
        "-- TEST: dialect=SQLite scope=tenant tenantId=tenant-123",
        "",
        // Sorted lexicographically by default:
        "PRAGMA journal_mode = WAL;",
        "PRAGMA synchronous = NORMAL;",
        "",
        "ATTACH DATABASE 'db3.sqlite.db' AS db3;",
        "ATTACH DATABASE 'db4.sqlite.db' AS db4;",
        "",
        "-- extra SQL (views, etc.)",
        "CREATE VIEW IF NOT EXISTS all_evidence AS",
        "SELECT 'db3' AS source_db, * FROM db3.evidence",
        "UNION ALL",
        "SELECT 'db4' AS source_db, * FROM db4.evidence;",
        "",
      ].join("\n");

      assertEquals(result.sql, golden);
    },
  );
});
